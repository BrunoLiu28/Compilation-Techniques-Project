Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    FALSE
    LSQUARE
    RSQUARE
    TRUE
    VOID_TYPE

Grammar

Rule 0     S' -> type
Rule 1     type -> INT_TYPE
Rule 2     type -> FLOAT_TYPE
Rule 3     type -> STRING_TYPE
Rule 4     type -> BOOL_TYPE
Rule 5     expression -> expression PLUS expression
Rule 6     expression -> expression MINUS expression
Rule 7     expression -> expression TIMES expression
Rule 8     expression -> expression DIVIDE expression
Rule 9     expression -> expression MOD expression
Rule 10    expression -> expression POWER expression
Rule 11    expression -> expression EQUAL expression
Rule 12    expression -> expression NOT_EQUAL expression
Rule 13    expression -> expression GREATER_THAN expression
Rule 14    expression -> expression GREATER_THAN_EQUAL expression
Rule 15    expression -> expression LESS_THAN expression
Rule 16    expression -> expression LESS_THAN_EQUAL expression
Rule 17    expression -> expression AND expression
Rule 18    expression -> expression OR expression
Rule 19    expression -> NOT expression
Rule 20    expression -> INTEGER_LITERAL
Rule 21    expression -> FLOAT_LITERAL
Rule 22    expression -> STRING_LITERAL
Rule 23    expression -> BOOL_LITERAL
Rule 24    expression -> ID
Rule 25    expression -> LPAREN expression RPAREN
Rule 26    constant_declaration -> VAL ID COLON type ASSIGN expression SEMICOLON
Rule 27    variable_declaration -> VAR ID COLON type ASSIGN expression SEMICOLON
Rule 28    function_declaration -> FUNCTION ID LPAREN function_param_list RPAREN COLON type SEMICOLON
Rule 29    function_declaration -> FUNCTION ID LPAREN function_param_list RPAREN COLON type LBRACE function_body RBRACE
Rule 30    function_param_list -> parameter COMMA function_param_list
Rule 31    function_param_list -> parameter
Rule 32    parameter -> VAL ID COLON type
Rule 33    parameter -> VAR ID COLON type
Rule 34    function_call -> ID LPAREN function_param_list_call RPAREN SEMICOLON
Rule 35    function_param_list_call -> ID COMMA function_param_list_call
Rule 36    function_param_list_call -> ID
Rule 37    function_body -> block_sequence
Rule 38    block_sequence -> block SEMICOLON block_sequence
Rule 39    block_sequence -> block
Rule 40    block -> constant_declaration
Rule 41    block -> variable_declaration
Rule 42    block -> if_block
Rule 43    block -> while_block
Rule 44    block -> function_call
Rule 45    block -> <empty>
Rule 46    if_block -> IF expression LBRACE block RBRACE LBRACE ELSE block RBRACE
Rule 47    if_block -> IF expression THEN block ELSE block
Rule 48    while_block -> WHILE expression LBRACE block RBRACE

Terminals, with rules where they appear

AND                  : 17
ASSIGN               : 26 27
BOOL_LITERAL         : 23
BOOL_TYPE            : 4
COLON                : 26 27 28 29 32 33
COMMA                : 30 35
COMMENT              : 
DIVIDE               : 8
ELSE                 : 46 47
EQUAL                : 11
FALSE                : 
FLOAT_LITERAL        : 21
FLOAT_TYPE           : 2
FUNCTION             : 28 29
GREATER_THAN         : 13
GREATER_THAN_EQUAL   : 14
ID                   : 24 26 27 28 29 32 33 34 35 36
IF                   : 46 47
INTEGER_LITERAL      : 20
INT_TYPE             : 1
LBRACE               : 29 46 46 48
LESS_THAN            : 15
LESS_THAN_EQUAL      : 16
LPAREN               : 25 28 29 34
LSQUARE              : 
MINUS                : 6
MOD                  : 9
NOT                  : 19
NOT_EQUAL            : 12
OR                   : 18
PLUS                 : 5
POWER                : 10
RBRACE               : 29 46 46 48
RPAREN               : 25 28 29 34
RSQUARE              : 
SEMICOLON            : 26 27 28 34 38
STRING_LITERAL       : 22
STRING_TYPE          : 3
THEN                 : 47
TIMES                : 7
TRUE                 : 
VAL                  : 26 32
VAR                  : 27 33
VOID_TYPE            : 
WHILE                : 48
error                : 

Nonterminals, with rules where they appear

block                : 38 39 46 46 47 47 48
block_sequence       : 37 38
constant_declaration : 40
expression           : 5 5 6 6 7 7 8 8 9 9 10 10 11 11 12 12 13 13 14 14 15 15 16 16 17 17 18 18 19 25 26 27 46 47 48
function_body        : 29
function_call        : 44
function_declaration : 
function_param_list  : 28 29 30
function_param_list_call : 34 35
if_block             : 42
parameter            : 30 31
type                 : 26 27 28 29 32 33 0
variable_declaration : 41
while_block          : 43

Parsing method: LALR

state 0

    (0) S' -> . type
    (1) type -> . INT_TYPE
    (2) type -> . FLOAT_TYPE
    (3) type -> . STRING_TYPE
    (4) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 2
    FLOAT_TYPE      shift and go to state 3
    STRING_TYPE     shift and go to state 4
    BOOL_TYPE       shift and go to state 5

    type                           shift and go to state 1

state 1

    (0) S' -> type .



state 2

    (1) type -> INT_TYPE .

    $end            reduce using rule 1 (type -> INT_TYPE .)


state 3

    (2) type -> FLOAT_TYPE .

    $end            reduce using rule 2 (type -> FLOAT_TYPE .)


state 4

    (3) type -> STRING_TYPE .

    $end            reduce using rule 3 (type -> STRING_TYPE .)


state 5

    (4) type -> BOOL_TYPE .

    $end            reduce using rule 4 (type -> BOOL_TYPE .)

